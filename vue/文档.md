## vue 基础用法

### 理论

#### 面试题 1： 简单聊聊对于 MVVM 的了解

- 发展史以及旁支
  - a. 语义化模板
  - b.MVC - model view controller - M:数据 V：视图 C：数据处理
  - c. MVVM - Model-View-ViewModel - 是个很宽泛的概念，vue 运用到了这个概念。MVVM 相对于 MVC 是进步的，例如 MVC 思想的 JQuery，要操作页面上的多数据，会很麻烦。
    - i. 数据会绑定在 viewModel 层并自动将数据渲染到页面中
    - ii. 视图变化时，会通知 viewModel 层更新数据

### 写法

#### vue 是如何利用 mvvm 思想进行项目开发

数据双向绑定

- a. 利用花括号，构筑了数据与视图的双向绑定 —— 若干正则

  - 利用花括号{{语句}}，构建了数据和视图的`双向绑定关系`。花括号里的并非变量本身，而是关系。所以 花括号 内只要是一个合法的语句就是 OK 的。

- b. 通过视图绑定事件，来处理数据

  - 通过视图绑定事件，来处理数据。(通过给标签添加事件 v-on:/@)

- 想象一个场景 页面多个地方运用到了{{num}} 通过某一个标签上的 @click 事件，给 num+=1，会发生什么样的效果？页面上所有的{{num}}都会加一。这就是 MVVM 思想的一种体现：触发视图的变化，通过事件改变数据，给 num 加一。又因为数据被绑定在若干个视图上，所以若干个视图又因为数据的变化而发生改动。这就是 MVVM。每一个{{}}都是数据和视图的桥梁。

小点：
main.js 是 vue 实例化的入口

#### data 不能用箭头函数，why？data 为什么是一个函数？

- 为什么是一个函数？- 避免多个 vue 组件污染 data。函数创建了作用域(封闭的执行区域)，不同组件中的变量不会相互污染。 - data 提供了当前组件的变量，子组件会被加载到父组件中，然后从根组件开始渲染。vue 在渲染，会有一个`依赖收集`的过程，判断当前变量会不会被另一个变量所依赖。判断组件最终会被合并成一套代码，为了隔离变量，似的变量都在自己的作用域里。...
- 为什么不能用箭头函数？后续补充一下...

#### 生命周期

##### 面试题 2：vue 生命周期

```
beforeCreate => created=>
beforeMount => mounted =>
beforeUpdate => updated=>
beforeDestroy => destroyed

// 关键字：创建 - vue的实例被创建。
bC: new Vue() - 只有一个空实例，实例挂载功能；
c: data、props、method、computed 被创建 - 故可以进行数据操作 但 不涉及到 vdom 和 dom。

// 关键词：挂载 - Dom节点挂载 - 把vDom往Dom上挂载.
bM: vDom - 数据操作，但是不可涉及 dom
m: Dom - 理论上可以进行任何操作

// 关键词：更新 - 视图的更新。
bU: vDom 更新了的，dom 未更新是旧的 - 可以更新数据。
u: dom 已经更新了 — 谨慎操作数据，尽量只去做读取的操作。

// 关键词：销毁 - 实例被销毁。
bD: 实例 vm 尚未被销毁 — 清空 eventBus、reset store、clear 计时器
d: 实例已经被销毁 - 收尾
```

小点：Vue.nextTick([callback, context]) - 在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM

- 不管 nextTick 写在哪个生命周期钩子函数中，都是在下一次`update`中调用了该方法。通过视图更新触发了 nextTick。
- 那为啥写在 created 中会比写在 mounted 中先执行呢？？？？？

小点：少用 setTimeout，不建议在生命周期中使用 setTimeout，因为不可靠，试试回调。

#### 定向监听

##### 面试点 3：computed 和 watch

相同点：

1. 基于 vue 的依赖收集机制
2. 都是被依赖的变化触发，进行改变进而进行处理计算

不同点：

1. 入和出

   - computed: 多入单出 —— 多个值变化，组成一个值的变化
     watch: 单入多出 —— 单个值的变化，进而影响一系列的状态变更

2. 性能

   - computed: 会自动 diff 依赖，若依赖没有变化，会改从缓存中读取当前计算值
     watch: 无论监听值变化与否，都会执行回调

3. 写法上

   - computed: 必须有 return 返回值
     watch: 不一定

4. 时机上
   - computed: 从首次生成赋值，就开始计算运行了
     watch: 首次不会运行，除非 设置 —— immediate：true

#### 条件

##### v-if & v-show & v-else & v-else-if

- v-if 无 dom，不会渲染实际节点及其子节点。
- v-show 存在实际节点及其子节点，但是 `不展示，不占据位置`。

经典面试题：窗口节点优化 - 通过 v-if 减少不必要的 DOM 渲染，从而优化性能。

#### 循环

##### 面试题： v-for 和 v-if 循优先级

> v-for > v-if 先循环 再判断

1:41:09

##### 面试题：循环 v-for 中 key 的作用

1. 模板编译原理 —— template => dom
   template => 正则匹配语法 —— 生成 AST：静态 + 动态 => 转换 AST 为可执行方法 => render() => dom

2. dom diff
   1 2 3 4 5 6

6 5 7 3 2 1

层级：只考虑单层复用，多层级遍历实现
顺序：双向指针，首尾向中间移动
替换：移动、新增、删除；优先复用 —— key => 快速识别顺序

3. key 作用 —— 尽可能复用节点
   常见问题：index 做 key、随机数做 key

#### 指令

##### 默认指令

v-once - 只渲染依次
v-text - 渲染字符串
v-html - 渲染 html
v-bind - : 绑定赋值
v-on - @ 监听
v-model - 双向绑定 —— 语法糖
:value + @input

- 重配置

```js
  model: {
    prop: 'selected',
    event: 'change'
  }
```

##### 自定义指令

```js
  directives: {
    zhaowa: {
      update: function() {
        // ……
      }
    }
  }
  <div v-zhaowa></div>
```

#### 事件

##### v-on

##### 修饰符

.stop .prevent .capture .self .once .passive

##### 按钮修饰符

enter delete

##### 事件设计 - 为何 vue 把事件写在模板上，而不是 js 中

模板定位事件触发源 + 触发源寻找触发事件逻辑 —— 更方便定位问题
js 与事件本身解耦 —— 更便于测试隔离
viewModel 销毁，自动解绑事件 —— 更便于回收

### 组件化

#### 一般组件 + 动态组件

## vue 进阶用法

### 优势一：模板化

#### 插槽 - 模板更加灵活

##### 默认插槽

组件外部维护参数以及结构，内部安排放置位置

##### 具名插槽

以 name 标识插槽的身份，从而在组件内部可以做到区分开来

##### 作用域插槽

可以接受 props（scope-slot）

#### 模板数据的二次加工上

##### 过滤器

```js
{
  {
    timer | format;
  }
}
```

##### v-html …… 指令化

##### jsx

##### 组件

### 优势二： 组件化

#### 传统模板化组件

```js
// 注册
Vue.component("component", {
  template: "<h2>Essential Links</h2>",
});

// 创建实例
new Vue({
  el: "#app",
});
```

##### 混入 mixin

- 1. 应用：抽离公共逻辑（逻辑相同，但是模板不一样）

面试题：
合并策略
a. data 冲突时，以组件主体为优先
b. 生命周期钩子会先后执行，先 mixin 后主体
c. 递归合并，递归合并优先级仍以主体优先

- 2. 缺点：数据来源不太明确

##### 继承拓展 extends

- 1. 应用：拓展独立逻辑

面试题：
合并策略 - 与 mixin 相同
a. 合并优先级上 mixin > extends
b. 回调优先级 extends > mixin

##### 整体拓展 —— extend

从预定义的配置中拓展一个独立配置项，并且进行合并

##### 插件 - Vue.use(VueRouter)

- 1. 注册外部插件，作为整体实例能力的补充
- 2. 自动做除重，防止多次重复注册相同插件
- 3. 编写插件
     a. 外部使用 Vue.use(myPlugin, options)
     b. 内部默认调用 install
